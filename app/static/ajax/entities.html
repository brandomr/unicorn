<div class="row">
    <div id="breadcrumb" class="col-md-12">
        <ol class="breadcrumb">
            <li><a href="index.html">Home</a></li>
            <li><a href="#">Entity Co-occurence Network</a></li>
        </ol>
    </div>
</div>
<div class="well"><a type="button" class="btn btn-default" id="dljs">Export JSON</a><div id="viz-container"></div></div>

<script type="text/javascript">

$(document).ready(function() {
    $.get('/viz_latest', function(data) { 
      var graph = JSON.parse(data);
      links = graph.links;
      nodes = graph.nodes;
      adj = graph.adj;

      console.log(graph);
      var width = $("#viz-container").parent().width(),
      height = 960,
      ent_colors = d3.scale.category20();

      console.log(ent_colors);
      var force = d3.layout.force()
        .nodes(d3.values(nodes))
        .links(links)
        .size([width, height])
        .linkDistance(50)
        .charge(-300)
        .on("tick", tick)
        .start();

      var svg = d3.select("#viz-container").append("svg")
        .attr("width", width)
        .attr("height", height);

      var path = svg.append("g").selectAll("path")
        .data(force.links())
        .enter().append("path")
        .attr("class", "link");
      
            var circle = svg.append("g").selectAll("circle")
        .data(force.nodes())
        .enter().append("circle")
        ////////////////////////////////////////////////
        // Different styling for documents vs. entities
        .attr("class", function (d) { return "node " + d.type; })
        ////////////////////////////////////////////////
        // Fill in colors based off type of entity (vs. single color documents)
        .style("fill", function(d) { 
            return d.type == "entity" ? ent_colors(d.category) : "white";
          })
        ////////////////////////////////////////////////
        // Size nodes based off the number of connections
        .attr("r", function(d) { return Object.keys(adj[d.id]).length + 3; })
        .call(force.drag)
        ////////////////////////////////////////////////
        // Event handler for when node is clicked
        .on("click", function(d) {
            console.log(d);
            })
        .on("mouseover", handle_mouseover)
        .on("mouseout", handle_mouseout);

      var text = svg.append("g").selectAll("text")
        .data(force.nodes())
        .enter().append("text")
        .attr("x", 8)
        .attr("y", "1em")
        .text(function(d) { 
            if (d.type == "entity") return d.id ;
            });
        
            function tick() {
        path.attr("d", linkArc);
        circle.attr("transform", transform);
        text.attr("transform", transform);
      }

      function linkArc(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y;
        return "M" + d.source.x + "," + d.source.y 
              + "L" + d.target.x + "," + d.target.y;
      }

      function transform(d) {
        return "translate(" + d.x + "," + d.y + ")";
      }

            function handle_mouseover(node) {
        // neighbors of neighbors:
        // track number of shared links between neighbors of neighbors
        var neighbors = {},
            neighbor_max = 1;
        for (var x in adj[node.id]) {
          neighbors[x] = x in neighbors ? neighbors[x]+1 : 1;
          for (var y in adj[x]) {
            if (y in neighbors && y != node.id){
              neighbors[y] += 1;
              neighbor_max = neighbors[y] > neighbor_max ? 
                neighbors[y] : neighbor_max;
            }
            else
              neighbors[y] = 1;
          }
        }
        neighbors[node.id] = neighbor_max;

        var delay = 100;
        circle.transition()
          .duration(delay)
          .style("opacity", function (d) {
            return (d.id in neighbors) ? neighbors[d.id]/neighbor_max + 0.1 : 0;
            });
        path.transition()
          .duration(delay)
          .style("stroke-width", function (d) {
            if (d.target.id in adj[node.id] || d.source.id in adj[node.id]) {
              if (node === d.target || node === d.source)
              {
                return 3;
              }
              else {
                return 1;
              }
            }
            else {
              return 0; 
            }
          })
          .style("stroke-dasharray", function(d) {
            if (d.target.id in adj[node.id] || d.source.id in adj[node.id]) {
            }
          })
        ;

        text.transition()
          .duration(delay)
          .style("opacity", function (d) {
            return (d.id in neighbors) ? 1 : 0;
          });
      }
    function handle_mouseout(node) {
        circle.transition().style("opacity", 1);
        path.transition().style("stroke-width", .1);
        text.transition().style("opacity", 1);
      }
 
var dtemp=graph.links.map(function(x){return {'s':x.source.id,'t':x.target.id,'file':x.target.origin}})
console.log(dtemp)
var data = "text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dtemp));
$("#dljs").attr("href", 'data:' + data );
$("#dljs").attr("download","data.json")
 });
});
</script>
